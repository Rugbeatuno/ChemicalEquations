const rref = require('rref');
const math = require('mathjs');

function halfToTerms(half) {
  return half.split('+').map(term => term.trim().replace(/ /g, ''));
}

function isInt(character) {
  return parseInt(character).toString() === character;
}

function isLower(character) {
  return !isInt(character) && character.toLowerCase() === character;
}

function isUpper(character) {
  return !isInt(character) && character.toUpperCase() === character;
}

function termToCoefficients(term) {
  //C6H14  Cu3O
  const parsed = term.split('').reduce(({ currentElement, elements }, character) => {
    if (currentElement.symbol && !isLower(character) && !isInt(character)) {
      elements.push({
        symbol: currentElement.symbol,
        count: currentElement.count || 1
      });
      currentElement = {
        symbol: '',
        count: ''
      };
    }
    if (isInt(character)) {
      return {
        currentElement: {
          symbol: currentElement.symbol,
          count: currentElement.count + character,
        },
        elements,
      };
    } else {
      return {
        currentElement: {
          symbol: currentElement.symbol + character,
          count: currentElement.count,
        },
        elements,
      };
    }
  }, { currentElement: { symbol: '', count: '' }, elements: [] });

  const lastElement = {
    symbol: parsed.currentElement.symbol,
    count: parsed.currentElement.count || 1,
  }

  const elements = [lastElement, ...parsed.elements].map(element => ({
    symbol: element.symbol,
    count: parseInt(element.count)
  }));

  return elements.reduce((map, { symbol, count }) => {
    map[symbol] = count;
    return map;
  }, {});
}

function floatToFraction(x, error = 0.000001) {
  const n = Math.floor(x)
  x -= n;
  if (x < error) {
    return [n, 1];
  } else if (1 - error < x) {
    return [n + 1, 1];
  }

  // the lower fraction is 0/1
  let lowerN = 0;
  let lowerD = 1;
  // the upper fraction is 1/1
  let upperN = 1;
  let upperD = 1;

  while (true) {
    // the middle fraction is (lowerN + upperN) / (lowerD + upperD)
    let middleN = lowerN + upperN;
    let middleD = lowerD + upperD;
    // if x + error < middle
    if (middleD * (x + error) < middleN) {
      // middle is our new upper
      upperN = middleN;
      upperD = middleD;
    } else if (middleN < (x - error) * middleD) {
      // middle is our new lower
      lowerN = middleN;
      lowerD = middleD;
    } else {
      // middle is our best fraction
      return [n * middleD + middleN, middleD];
    }
  }
}

function removeParens(equation) {
  const hasParens = equation.match(/\(([^()]+)\)([0-9]+)/gi);

  if (!hasParens) {
    return equation;
  }
  const parensMatches = hasParens.length;

  let lastIndex = 0;
  let newEquation = equation;
  for (let i = 0; i < parensMatches; i += 1) {
    const match = /\(([^()]+)\)([0-9]+)/gi.exec(newEquation.substring(lastIndex));
    const fullMatch = match[0];
    const insideParen = match[1];
    const multiplier = parseInt(match[2]);

    const term = termToCoefficients(insideParen);
    const newTerm = (Object
      .keys(term)
      .map(key => ({ key, value: term[key] }))
      .map(({ key, value }) => ({ key, value: value * multiplier }))
      .reduce((newString, { key, value }) => newString + key + value, '')
    )

    lastIndex = (equation.substring(0, match.index) + newTerm).length;

    const first = newEquation.substring(0, match.index);
    const second = newTerm;
    const third = newEquation.substring(match.index + fullMatch.length);

    newEquation = first + second + third;
  }

  return removeParens(newEquation);
}

function removeOtherCharacters(equation) {
  return equation.replace(/[^A-Z0-9+->()]/gi, '');
}

function balance(equation) {
  const equationNoExtraCharacters = removeOtherCharacters(equation);
  const equationWithoutParens = removeParens(equationNoExtraCharacters);
  const [firstHalf, secondHalf] = equationWithoutParens.split('->').map(half => half.trim());

  const termsFirstHalf = halfToTerms(firstHalf).map(termToCoefficients);
  const termsSecondHalf = halfToTerms(secondHalf).map(termToCoefficients);

  const uniqueElements = Object.keys([...termsFirstHalf, ...termsSecondHalf].reduce((elements, term) => {
    for (let element of Object.keys(term)) {
      elements[element] = true;
    }
    return elements;
  }, {}));

  const termsNormalized = [
    ...termsFirstHalf,
    ...termsSecondHalf.map(term =>
      Object.keys(term).map(key => ({ key, value: -term[key] })).reduce((term, { key, value }) => {
        term[key] = value;
        return term;
      }, {})
    )
  ];

  const matrix = uniqueElements.map(element => termsNormalized.map(term => term[element] || 0));
  rref(matrix);
  const fractions = matrix.map(row => floatToFraction(-row[3]));
  const lcm = math.lcm(...fractions.map(fraction => fraction[1]));
  const coefficients = fractions.map(([n, d]) => n * (lcm / d)).filter(x => x);

  return [...coefficients, lcm];
}

module.exports = balance;